<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Camera or Image Display</title>
    <!-- google font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Anybody:wdth,wght@64,900&display=swap" rel="stylesheet">
    <!-- p5.js library -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: sans-serif;
      }
      canvas {
        display: block;
        touch-action: none; /* disables scroll/zoom gestures on canvas */
        z-index: 0;
      }
      /* base (desktop-first): 4 columns, each max 120px, left-aligned */
    #controls {
        position: absolute;
        bottom: 8px;
        left: 0;
        width: 100%;
        box-sizing: border-box;
        padding: 0 8px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 120px)); /* each column up to 120px */
        gap: 8px;
        justify-content: start; /* left-align columns */
        z-index: 10;
    }

    #controls > div {
        display: flex;
        flex-direction: column;
        align-items: stretch;   /* buttons fill the column width */
    }

        /* Make buttons / label consistent */
    button,
    .button-like {
        margin: 4px 0;
        padding: 8px 12px;
        font-size: 12px;
        font-family: inherit;
        font-weight: 300;
        background-color: linen;
        border-radius: 12px;
        border: none;
        text-align: center;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        width: 100%;
        box-sizing: border-box;
    }

        /* hidden native file input */
    input[type="file"][hidden] {
        display: none;
    }

    /* MOBILE: make columns equal width across the full width */
    @media (max-width: 600px) {
        #controls {
            grid-template-columns: repeat(4, 1fr); /* 4 equal columns */
            gap: 8px;
            padding: 8px;
        }

        button,
        .button-like {
            font-size: 12px;
            padding: 8px 8px;
        }
    }


</style>
</head>
    <body>
        <div id="controls">
    <div>
        <button id="clearBtn">Clear Grad</button>
        <button id="freezeGradBtn">Freeze Grad</button>
    </div>

    <div>
        <input type="file" id="fileInput" accept="image/*" hidden>
        <label for="fileInput" class="button-like">Load Image</label>
        <button id="toggleBtn">Show Camera</button>
    </div>

    <div>
        <button id="MapGradBtn">Map Grad</button>
    </div>

    <div>
        <button id="exportGradBtn">Export Grad</button>
        <button id="exportImageBtn">Export Image</button>
    </div>
    </div>


    <script>
      let canvas // the p5 canvas

      let constraints = {
        video: {
            facingMode: "environment"  // request rear camera
        },
        audio: false
      };

      let cam;
      let imgLoaded = null;
      let showImage = false;

      let freezeGrad = false; // toggle if grad is frozen
      let mapGrad = false; // apply the gradient to the image!
      let gradientMap = null;

      let imgRender = null; // place to render the image
      let drwRender = null; // place to render the gradient drawings
      let drawing = false; // store if we are drawing or not
      let drwPoints = []; // array to store drawn points
      let grdRender = null; // place to render gradient
      let rndBackground = null;

      let svgCodeSimple = `
<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200">
  <circle cx="100" cy="100" r="80" fill="orange" stroke="black" stroke-width="4"/>
</svg>
`;

      let svgImg;

      function preload() {
        let dpr = window.devicePixelRatio || 1;
        let path = (dpr > 1) ? "logo@2x.png" : "logo.png";
        svgImg = loadImage(path);
      }

      function setup() {
        canvas = createCanvas(windowWidth, windowHeight);
        canvas.mousePressed(handleMousePressed);
        canvas.mouseReleased(handleMouseReleased);
        canvas.touchStarted(handleMousePressed);
        canvas.touchEnded(handleMouseReleased);
        
        cam = createCapture(constraints);
        cam.size(windowWidth, windowHeight);
        cam.hide();

        // Clear Gradient
        document.getElementById('clearBtn').addEventListener('click', () => {
            drwPoints = [];
            drwRender.clear();
            //
            freezeGrad = false;
            document.getElementById('freezeGradBtn').innerText = !freezeGrad ? "Freeze Grad" : "Unfreeze Grad";
        });

        // Freeze Gradient
        document.getElementById('freezeGradBtn').addEventListener('click', () => {
            freezeGrad = !freezeGrad;
            document.getElementById('freezeGradBtn').innerText = !freezeGrad ? "Freeze Grad" : "Unfreeze Grad";
        });

        // export Gradient image
        document.getElementById('exportGradBtn').addEventListener('click', () => {
            grdRender.save("grad-"+ Date.now() +".png");
        });

        // Map Gradient
        document.getElementById('MapGradBtn').addEventListener('click', () => {
            freezeGrad = true;
            document.getElementById('freezeGradBtn').innerText = "Unfreeze Grad";
            mapGrad = !mapGrad;
            document.getElementById('MapGradBtn').innerText = !mapGrad ? "Map Grad" : "Unmap Grad";
            // make the gradient
            //gradientMap = createGradientLUT(color(0, 0, 0), color(255, 0, 0));
            gradientMap = createBigGradientLUT(drwPoints);
        });

        // File input
        document.getElementById('fileInput').addEventListener('change', handleFile);

        // Toggle button
        document.getElementById('toggleBtn').addEventListener('click', () => {
          if (imgLoaded) {
            showImage = !showImage;
            document.getElementById('toggleBtn').innerText = showImage ? "Flip to Camera" : "Flip to Image";
          }
        });

        // export Gradient image
        document.getElementById('exportImageBtn').addEventListener('click', () => {
            imgRender.save("img-"+ Date.now() +".png");
        });

        imgRender = createGraphics(windowWidth,windowHeight);
        imgRender.background(255,255,0);
        //
        drwRender = createGraphics(windowWidth,windowHeight);
        //
        grdRender = createGraphics(windowWidth, 60);
        // create a randomgradient as a fun backdrop on load
        rndBackground = createGraphics(windowWidth,windowHeight);
        let c1 = color(random(255), random(255), random(255));
        let c2 = color(random(255), random(255), random(255));
        for(let x=0; x<windowWidth; x++) {
            let cl = lerpColor(c1,c2,x/windowWidth);
            rndBackground.stroke(cl);
            rndBackground.line(x,0,x,windowHeight);
        }
        /*rndBackground.textSize(64);
        rndBackground.textFont("Anybody");
        rndBackground.textAlign(CENTER, CENTER);
        rndBackground.text("GRADIENT",width/2,height/2);*/
        
        rndBackground.image(svgImg, width/2 - svgImg.width/4, height/2 - svgImg.height/4, svgImg.width/2, svgImg.height/2);
      }

      function draw() {
        background(0);

        // image work
        if (imgLoaded && showImage) {
          //image(img, 0, 0, width, height);
          imgRender.copy(imgLoaded,0,0,imgLoaded.width,imgLoaded.height,0,0, windowWidth,windowHeight);
        } else {
          //image(cam, 0, 0, width, height);
          imgRender = cam.get();
        }
        

        // drawing work
        drwRender.clear();
        drwRender.stroke(255,128);
        let dl = drwPoints.length-1;
        //console.log(dl);

        // big branch are we getting gradients or mapping them

        if(!mapGrad) {

            // add points?
            if(!freezeGrad) {
                if(drawing) {
                    // get the color, store, however this isn't correct if the images moves
                    // and we want to get the values at time of save/map
                    let mget = imgRender.get(mouseX,mouseY);
                    //console.log(mget);
                    if(dl >= 0) {
                        let r = dist(mouseX,mouseY,drwPoints[dl].x,drwPoints[dl].y);
                        if(r>5) {
                            drwPoints.push({x:mouseX,y:mouseY,c:mget});
                        }
                    } else {
                        drwPoints.push({x:mouseX,y:mouseY,c:mget});
                    }
                }
            }

            // draw existing line
            drwRender.strokeWeight(4);
            for(let i=0; i<drwPoints.length-1; i++) {
                //drwRender.stroke(drwPoints[i].c[0],drwPoints[i].c[1],drwPoints[i].c[2]); //get historical points
                let col = imgRender.get(drwPoints[i].x,drwPoints[i].y);
                //drwRender.stroke(col[0],col[1],col[2]); //not getting local color
                drwRender.line(drwPoints[i].x,drwPoints[i].y,drwPoints[i+1].x,drwPoints[i+1].y);
            }

            // make gradient
            grdRender.clear();
            grdRender.background(255);
            grdRender.strokeWeight(2);
            let d = grdRender.width/(drwPoints.length-1);
            //console.log(grdRender.width);
            for(let i=0; i<drwPoints.length-1; i++) {
                if(!freezeGrad) {
                    drwPoints[i].c = imgRender.get(drwPoints[i].x,drwPoints[i].y);
                    drwPoints[i+1].c = imgRender.get(drwPoints[i+1].x,drwPoints[i+1].y);
                }
                let get1 = drwPoints[i].c//imgRender.get(drwPoints[i].x,drwPoints[i].y);
                let get2 = drwPoints[i+1].c//imgRender.get(drwPoints[i+1].x,drwPoints[i+1].y);
                let col1 = color(get1[0],get1[1],get1[2]);
                let col2 = color(get2[0],get2[1],get2[2]);
                
                for(let j=0; j<d; j++) {
                    let inc = j/d;
                    let cl = lerpColor(col1,col2,inc);
                    grdRender.stroke(cl);
                    grdRender.line(i*d+j,5,i*d+j,55);
                }
                // simple render 1 line per drawn point
                //grdRender.stroke(col1);
                //grdRender.line(i*d,50,i*d,100);
            }

        } else {
            /*let gradientColors = [
                color(0, 0, 255), // Blue
                color(0, 255, 0), // Green
                color(255, 0, 0)  // Red
            ];
            imgRender.loadPixels();
            for (let i = 0; i < imgRender.pixels.length; i += 4) {
                let r = imgRender.pixels[i];
                let g = imgRender.pixels[i + 1];
                let b = imgRender.pixels[i + 2];

                // Calculate brightness (you can use other methods too)
                let brightness = (r + g + b) / 3;

                // Map brightness to a position in the gradient (0 to 1)
                let gradientPosition = map(brightness, 0, 255, 0, 1);

                // Interpolate color from the gradient
                let newColor;
                if (gradientPosition <= 0.5) {
                // Interpolate between gradientColors[0] and gradientColors[1]
                let mappedPos = map(gradientPosition, 0, 0.5, 0, 1);
                newColor = lerpColor(gradientColors[0], gradientColors[1], mappedPos);
                } else {
                // Interpolate between gradientColors[1] and gradientColors[2]
                let mappedPos = map(gradientPosition, 0.5, 1, 0, 1);
                newColor = lerpColor(gradientColors[1], gradientColors[2], mappedPos);
                }

                imgRender.pixels[i] = red(newColor);
                imgRender.pixels[i + 1] = green(newColor);
                imgRender.pixels[i + 2] = blue(newColor);
                // Alpha remains the same: image.pixels[i + 3]
            }
            imgRender.updatePixels();
            */

            imgRender.loadPixels();
            for (let i = 0; i < imgRender.pixels.length; i += 4) {
                // grayscale intensity
                let brightness = 0.3 * imgRender.pixels[i] + 0.59 * imgRender.pixels[i + 1] + 0.11 * imgRender.pixels[i + 2];
                let col = gradientMap[Math.floor(brightness)];
                
                imgRender.pixels[i + 0] = col[0]; // R
                imgRender.pixels[i + 1] = col[1]; // G
                imgRender.pixels[i + 2] = col[2]; // B
                imgRender.pixels[i + 3] = 255;    // A
            }
            imgRender.updatePixels();
        }

        // render all bits
        image(rndBackground,0,0);
        image(imgRender,0,0);
        image(drwRender,0,0);
        image(grdRender,0,0);
        
      }

      // ---- LUT helper ----
      function createGradientLUT(c1, c2) {
        let lut = [];
        for (let i = 0; i < 256; i++) {
            let amt = i / 255;
            let r = lerp(red(c1), red(c2), amt);
            let g = lerp(green(c1), green(c2), amt);
            let b = lerp(blue(c1), blue(c2), amt);
            lut.push([r, g, b]);
        }
        return lut;
      }

      function createBigGradientLUT(colors) {

        //let div = 256/colors.length;
        let tmp = createGraphics(256,grdRender.height);
        tmp.copy(grdRender,0,0,grdRender.width,grdRender.height, 0,0,256,tmp.height);
        let lut = [];
        for (let i = 0; i < 256; i++) {
            //let amt = i / 255;
            //let r = lerp(red(c1), red(c2), amt);
            //let g = lerp(green(c1), green(c2), amt);
            //let b = lerp(blue(c1), blue(c2), amt);
            //lut.push([r, g, b]);
            let c = tmp.get(i,tmp.height/2);
            lut.push([c[0], c[1], c[2]]);
            
        }
        return lut;
      }

      
      // - - - interaction
      function handleMousePressed() {
        drawing = true;
        console.log("do some drawing");
      }

      function handleMouseReleased() {
        drawing = false;
      }

      function handleFile(event) {
        let file = event.target.files[0];
        if (file && file.type.startsWith('image')) {
          let reader = new FileReader();
          reader.onload = e => {
            loadImage(e.target.result, loadedImg => {
              imgLoaded = loadedImg;
              showImage = true;
              document.getElementById('toggleBtn').innerText = "Show Camera";
            });
          };
          reader.readAsDataURL(file);
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        imgRender = createGraphics(windowWidth, windowHeight);
        drwRender = createGraphics(windowWidth, windowHeight);
        grdRender = createGraphics(windowWidth, 60);
      }
    </script>
  </body>
</html>
